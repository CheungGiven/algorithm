KubernetesクラスタはコントロールプレーンとNodeのアーキテクチャが分離しているため、クラスタをデプロイする際には通常、同じバージョンのコントロールプレーンと同じバージョンのNodeをデプロイすることを選択する。しかし、クラスタのバージョンをアップグレードしたい場合、アップグレードの過程でコントロールプレーンとNodeが同じバージョンを維持できないことがわかります。

例えば

v1.23のKubernetesクラスタをデプロイし、コントロールプレーンとNodeは現在v1.23です。
コントロールプレーンをv1.24にアップグレードします。
コントロールプレーンをv1.24にアップグレードします。Nodeはまだv1.23のままです。
最後に、ノードをv1.24にアップグレードします。
このアップグレードプロセスの間、しばらくの間、コントロールプレーンとノードが同じバージョンではありません。

一般的に言って、このような分離されたアーキテクチャを持つほとんどのソフトウェアでは、バージョンの不一致が問題になる可能性が高いです（ここでは一部のシステム/ソフトウェアについては言及しません）。しかし、上記のプロセスは明らかに存在しなければならないので、Kubernetesはこの点に関して特に対処し、互換性を持たせている 。 このポリシーをKubernetesのバージョンバイアス・ポリシーと呼ぼう。

Kubernetesは、コントロールプレーンのバージョンとノードのバージョンの間にn-2のずれを許容する。 例えば

コントロールプレーンのバージョンはv1.27
ノードのバージョンはv1.27、v1.26、v1.25。
しかし、v1.28からは、このバージョン逸脱ポリシーがn-3まで拡張される：

コントロールプレーンのバージョンはv1.28
ノードのバージョンはv1.28、v1.27、v1.26、v1.25となる。
このバージョンの偏りポリシーについて説明した後、これがどれほど重要なのかを見てみよう。

Kubernetesの現在のリリース＆サポートポリシーは、ユーザーは1年以内にセキュリティ修正パッチが適用された最新バージョンに継続的にアップグレードすることができ、3回の連続バージョンアップでサポートされる最新バージョンに追いつくことができるようになっている。

しかし、コントロール・プレーンとノードの間のテスト/サポートの乖離は、現在n-2リリースに制限されているため、1年に3回のリリース・アップグレードは、サポートされる範囲内にとどまるために、2つのノードのアップグレードを行う必要があります。 例えば、v1.24からv1.27へのアップグレードのシナリオは、2022年の最初のリリースから2023年の最初のリリースへのアップグレードと全く同じです。

コントロールプレーンとノードは両方ともv1.24です。
コントロールプレーンのアップグレード v1.24 - v1.25 - v1.26。
ノードのアップグレード v1.24 - v1.26; コントロール・プレーンのアップグレード v1.26 - v1.26。
コントロール・プレーン・アップグレード v1.26 - v1.27
ノードのアップグレード v1.26 - v1.27
ここでわかるように、Nodeは2回アップグレードする必要がある。 実際、Kubernetesクラスタのメンテナンス中、Nodeのバージョンをアップグレードすることによる影響は大きく、例えば、これらのNode上で動作していたPodを再スケジュール／再構築する必要があるなど、理想的には業務に影響を与えないようにする必要がある（が、現実には影響がある...）。さらに、クラスタサイズが大きくなると、このノードのアップグレードの作業負荷も非常に大きくなります。

新しいn-3偏差ポリシーを使用する場合、その効果、つまりv1.24からv1.27まで（これはあくまで例であり、v1.28から効果を発揮します）を見てみましょう：

コントロールプレーンもノードもv1.24です。
コントロール・プレーンのアップグレード v1.24 - v1.25 - v1.26 - v1.27; ノードのアップグレード v1.24 - v1.25 - v1.26 - v1.27.
ノードのアップグレード v1.24 - v1.27。
このように、Nodeのアップグレードは1回で済むため、作業量が大幅に削減され、ビジネスへの影響も軽減されるのは明らかだ。

www.DeepL.com/Translator（無料版）で翻訳しました。
