# LintCode Ladder
## level 1 BackTracking
* [strStr](./java/strStr.java)
* [strStr II](./java/strStr2.java)
* [Subsets](./java/subsets.java)
* [Subsets II](./java/subsets2.java)
* [Permutations](./java/permutations.java)
* [Permutations II](./java/permutations2.java)
* [Longest Palindrome](./java/longestPalindrome.java)
* [Valid Palindrome](./java/validPalindrome.java)
* [Longest Palindromic Substring](./java/longestPalindromicSubstring.java)

## level 2 Binary Search
* [Closest Number in Sorted Array](./java/closetNumberInSortedArray.java)
* [Last Position of Target](./java/lastPositionofTarget.java)
* [Search a 2D Matrix](./java/searcha2DMatrix.java)
* [Maximum Number in Mountain Sequence](./java/maximumNumberInMountainSequence.java)
* [Search in a Big Sorted Array](./java/searchInABigSortedArray.java)
* [Find Minimum in Rotated Sorted Array](./java/findMinimumInRotatedSortedArray.java)
* [Find Peak Element](./java/findPeakElement.java)
* [First Bad Version](./java/firstBadVersion.java)
* [Search in Rotated Sorted Array](./java/searchInRotatedSortedArray.java)
* [Total Occurrence of Target](./java/totalOccurrenceOfTarget.java)
* [Drop Eggs](./java/dropEggs.java)
* [First Position of Target](./java/firstPositionOfTarget.java)
* [K Closest Numbers In Sorted Array](./java/KClosestNumbersInSortedArray.java)
* [Divide Two Integers](./java/DivideTwoIntegers.java)
* [Search for a Range](./java/SearchforaRange.java)
* [Search a 2D Matrix II](./java/Searcha2DMatrix2.java)
* [Smallest Rectangle Enclosing Black Pixels](./java/SmallestRectangleEnclosingBlackPixels.java)
* [Sqrt(x)](./java/Sqrt.java)
* [Maximum Average Subarray](./java/MaximumAverageSubarray.java)
* [Find Minimum in Rotated Sorted Array II](./java/FindMinimuminRotatedSortedArray2.java)
* [Search in Rotated Sorted Array II](./java/SearchinRotatedSortedArray2.java)
* [Copy Books](./java/CopyBooks.java)
* [Wood Cut](./java/WoodCut.java)
* [Pow(x, n)](./java/Pow.java)
* [Fast Power](./java/FastPower.java)

## level 3 Binary Tree & Divide Coquer
* [Minimum Depth of Binary Tree with Maximum Average](./java/MinimumDepthofBinaryTreewithMaximumAverage.java)
* [Minimum Subtree](./java/MinimumSubtree.java)
* [Binary Tree Paths](./java/BinaryTreePaths.java)
* [Flatten Binary Tree to Linked List](./java/FlattenBinaryTreetoLinkedList.java)
* [Maximum Depth of Binary Tree](./java/MaximumDepthofBinaryTree.java)
* [Binary Tree Preorder Traversal](./java/BinaryTreePreorderTraversal.java)
* [Balanced Binary Tree](./java/BalancedBinaryTree.java)
* [Binary Tree Inorder Traversal](./java/BinaryTreeInorderTraversal.java)
* [Binary Tree Postorder Traversal](./java/BinaryTreePostorderTraversal.java)
* [Validate Binary Search Tree](./java/ValidateBinarySearchTree.java)
* [Binary Tree Longest Consecutive Sequence](./java/BinaryTreeLongestConsecutiveSequence.java)
* [Binary Tree Longest Consecutive Sequence II](./java/BinaryTreeLongestConsecutiveSequence2.java)
* [Binary Tree Longest Consecutive Sequence III](./java/BinaryTreeLongestConsecutiveSequence3.java)
* [Binary Tree Path Sum](./java/BinaryTreePathSum.java)
* [Binary Tree Path Sum II](./java/BinaryTreePathSum2.java)
* [Binary Tree Path Sum III](./java/BinaryTreePathSum3.java)
* [Binary Tree Maximum Path Sum II](./java/BinaryTreeMaximumPathSum2.java)
* [Inorder Successor in Binary Search Tree](./java/InorderSuccessorinBinarySearchTree.java)
* [Convert Binary Search Tree to Doubly Linked List](./java/ConvertBinarySearchTreetoDoublyLinkedList.java)
* [Minimum Depth of Binary Tree](./java/minimumDepthOfBinaryTree.java)
* [Lowest Common Ancestor](./java/LowestCommonAncestor.java)
* [Lowest Common Ancestor II](./java/LowestCommonAncestor2.java)
* [Lowest Common Ancestor III](./java/LowestCommonAncestor3.java)

## level 4 Breadth First Search
* [Number of Islands](./java/NumberOfIslands.java)
* [Number of Islands II](./java/NumberOfIslands2.java)
* [Binary Tree Level Order Traversal](./java/binaryTreeLevelOrderTraversal.java)
* [Binary Tree Level Order Traversal II](./java/binaryTreeLevelOrderTraversal2.java)
* [Course Schedule](./java/CourseSchedule.java)
* [Course Schedule II](./java/CourseSchedule2.java)
* [Search Graph Nodes](./java/SearchGraphNodes.java)
* [Knight Shortest Path](./java/KnightShortestPath.java)
* [Knight Shortest Path II](./java/KnightShortestPath2.java)
* [Zombie in Matrix](./java/ZombieinMatrix.java)
* [Graph Valid Tree](./java/GraphValidTree.java)
* [Clone Graph](./java/CloneGraph.java)
* [Binary Tree Serialization](./java/BinaryTreeSerialization.java)
* [Build Post Office](./java/BuildPostOffice.java)
* [Build Post Office II](./java/BuildPostOffice2.java)
* [Convert Binary Tree to Linked Lists by Depth](./java/ConvertBinaryTreetoLinkedListsbyDepth.java)
* [Remove Substrings](./java/RemoveSubstrings.java)
* [Sequence Reconstruction](./java/SequenceReconstruction.java)
* [Six Degrees](./java/SixDegrees.java)
* [Topological Sorting](./java/TopologicalSorting.java)
* [Word Ladder](./java/wordLadder.java)
* [Connected Component in Undirected Graph](./java/ConnectedComponentinUndirectedGraph.java)
* [Binary Tree Zigzag Level Order Traversal](./java/BinaryTreeZigzagLevelOrderTraversal.java)
* [Smallest Rectangle Enclosing Black Pixels](./java/SmallestRectangleEnclosingBlackPixels.java)


## level 5 Depth First Search
* [Palindrome Partitioning](./java/palindromePartitioning.java)
* [Combination Sum](./java/combinationSum.java)
* [Combination Sum II](./java/combinationSum2.java)
* [Subsets II](./java/subsets2.java)
* [Permutations](./java/permutations.java)
* [Permutations II](./java/permutations2.java)
* [Word Ladder](./java/wordLadder.java)
* [Word Ladder II](./java/wordLadder2.java)
* [Next Permutation](./java/NextPermutation.java)
* [Next Permutation II](./java/NextPermutation2.java)
* [Previous Permutation](./java/PreviousPermutation.java)
* [Palindrome Partitioning II](./java/PalindromePartitioning2.java)
* [Word Break](./java/WordBreak.java)
* [Word Break II](./java/WordBreak2.java)
* [String Permutation](./java/StringPermutation.java)
* [String Permutation II](./java/StringPermutation2.java)
* [Permutation Index](./java/PermutationIndex.java)
* [Permutation Index II](./java/PermutationIndex2.java)


## level 6 Linked List & Array
* [Insert into a Cyclic Sorted List](./java/insertInToACyclicSortedList.java)
* [Merge Two Sorted Lists](./java/mergeTwoSortedLists.java)
* [Subarray Sum](./java/SubarraySum.java)
* [Maximum Subarray](./java/MaximumSubarray.java)
* [Maximum Subarray II](./java/MaximumSubarray2.java)
* [Maximum Subarray III](./java/MaximumSubarray3.java)
* [Maximum Subarray IV](./java/MaximumSubarray4.java)
* [Maximum Subarray V](./java/MaximumSubarray5.java)
* [Subarray Sum Closest](./java/SubarraySumClosest.java)
* [Copy List with Random Pointer](./java/copyListwithRandomPointer.java)
* [Linked List Cycle](./java/linkedListCycle.java)
* [Linked List Cycle II](./java/linkedListCycle2.java)
* [Sort List](./java/sortList.java)
* [Reverse Nodes in k-Group](./java/reverseNodesInk-Group.java)
* [Median of two Sorted Arrays](./java/medianOfTwoSortedArrays.java)
* [Intersection of Two Arrays](./java/intersectionOfTwoArrays.java)
* [Intersection of Two Arrays II](./java/intersectionOfTwoArrays2.java)
* [Partition List](./java/PartitionList.java)
* [Merge Sorted Array](./java/MergeSortedArray.java)
* [Merge Two Sorted Arrays](./java/MergeTwoSortedArrays.java)
* [Maximum Average Subarray](./java/MaximumAverageSubarray.java)
* [Maximum Product Subarray](./java/MaximumProductSubarray.java)
* [Maximum Subarray Difference](./java/MaximumSubarrayDifference.java)

## level 7 Two Pointers
* [Two Sum - Data structure design](./java/twoSumDataStructureDesign.java)
* [Two Sum](./java/TwoSum.java)
* [Two Sum - Input array is sorted](./java/TwoSum-Inputarrayissorted.java)
* [Two Sum - Less than or equal to target](./java/twoSum-LessThanOrEqualToTarget.java)
* [Two Sum - Unique pairs](./java/twoSum-UniquePairs.java)
* [Two Sum - Closest to target](./java/twoSum-ClosestToTarget.java)
* [Two Sum - Difference equals to target](./java/TwoSum-Differenceequalstotarget.java)
* [Two Sum - Greater than target](./java/TwoSum-Greaterthantarget.java)
* [Two Sum III - Data structure design](./java/TwoSum3-DataStructureDesign.java)
* [3Sum](./java/3Sum.java)
* [3Sum Closest](./java/3SumClosest.java)
* [4Sum](./java/4Sum.java)
* [Remove Duplicate Numbers in Array](./java/removeDuplicateNumbersInArray.java)
* [Sort Colors](./java/SortColors.java)
* [Sort Colors II](./java/)
* [Partition Array](./java/partitionArray.java)
* [Partition Array II](./java/partitionArray2.java)
* [Window Sum](./java/WindowSum.java)
* [Move Zeroes](./java/MoveZeroes.java)
* [Valid Palindrome](./java/validPalindrome.java)
* [Valid Palindrome II](./java/validPalindrome2.java)
* [Kth Smallest Numbers in Unsorted Array](./java/KthSmallestNumbersinUnsortedArray.java)
* [Triangle Count](./java/TriangleCount.java)
* [Middle of Linked List](./java/MiddleofLinkedList.java)
* [Sort Integers](./java/SortIntegers.java)
* [Sort Integers II](./java/SortIntegers2.java)
* [Kth Largest Element](./java/KthLargestElement.java)
* [Pancake Sorting](./java/PancakeSorting.java)
* [Intersection of Two Linked Lists](./java/)
* [Linked List Cycle](./java/linkedListCycle.java)
* [Linked List Cycle II](./java/linkedListCycle2.java)

## level 8 Data Structure
* [Hash Function](./java/HashFunction.java)
* [High Five](./java/HighFive.java)
* [K Closest Points](./java/KClosestPoints.java)
* [Kth Largest Element II](./java/KthLargestElement2.java)
* [Top k Largest Numbers](./java/TopkLargestNumbers.java)
* [Top k Largest Numbers II](./java/TopkLargestNumbers2.java)
* [Rehashing](./java/Rehashing.java)
* [Merge k Sorted Lists](./java/MergekSortedLists.java)
* [Ugly Number](./java/UglyNumber.java)
* [Ugly Number II](./java/UglyNumber2.java)
* [strStr II](./java/strStr2.java)
* [LRU Cache](./java/LRUCache.java)
* [LFU Cache](./java/LFUCache.java)
* [Flatten 2D Vector](./java/Flatten2DVector.java)
* [Merge k Sorted Arrays](./java/MergekSortedArrays.java)
* [Top K Frequent Words](./java/TopKFrequentWords.java)
* [Top K Frequent Words(Map Reduce)](./java/TopKFrequentWordsMapReduce.java)
* [Top K Frequent Words II](./java/TopKFrequentWords2.java)
* [Heapify](./java/Heapify.java)
* [Longest Consecutive Sequence](./java/LongestConsecutiveSequence.java)
* [Nested List Weight Sum](./java/NestedListWeightSum.java)
* [Nested List Weight Sum II](./java/NestedListWeightSum2.java)
* [Implement Stack by Two Queues](./java/ImplementStackbyTwoQueues.java)
* [Expression Expand](./java/ExpressionExpand.java)
* [Zigzag Iterator](./java/ZigzagIterator.java)
* [Zigzag Iterator II](./java/ZigzagIterator2.java)
* [Flatten Nested List Iterator](./java/FlattenNestedListIterator.java)

## level 9 Dynamic Programming
* [Unique Paths](./java/UniquePaths.java)
* [Unique Paths II](./java/UniquePaths2.java)
* [Climbing Stairs](./java/ClimbingStairs.java)
* [Climbing Stairs II](./java/ClimbingStairs2.java)
* [Minimum Path Sum](./java/MinimumPathSum.java)
* [Triangle](./java/Triangle.java)
* [Largest Divisible Subset](./java/LargestDivisibleSubset.java)
* [Knight Shortest Path](./java/KnightShortestPath.java)
* [Knight Shortest Path II](./java/KnightShortestPath2.java)
* [Perfect Squares](./java/PerfectSquares.java)
* [Jump Game](./java/JumpGame.java)
* [Jump Game II](./java/JumpGame2.java)
* [Longest Increasing Subsequence](./java/LongestIncreasingSubsequence.java)
* [Russian Doll Envelopes](./java/RussianDollEnvelopes.java)
* [Frog Jump](./java/FrogJump.java)
* [Drop Eggs](./java/DropEggs.java)
* [Drop Eggs II](./java/DropEggs2.java)



# LintCode Ladder advance
## level 1 Windows Moving
* [Kth Smallest Number in Sorted Matrix](./java/KthSmallestNumberInSortedMatrix.java)
* [Minimum Size Subarray Sum](./java/MinimumSizeSubarraySum.java)
* [Longest Substring Without Repeating Characters](./java/LongestSubstringWithoutRepeatingCharacters.java)
* [Longest Substring with At Most K Distinct Characters](./java/LongestSubstringWithAtMostKDistinctCharacters.java)
* [Kth Smallest Sum In Two Sorted Arrays](./java/KthSmallestSumInTwoSortedArrays.java)
* [Kth Largest in N Arrays](./java/KthLargestinNArrays.java)
* [Two Sum - Less than or equal to target](./java/TwoSum-Lessthanorequaltotarget.java)
* [Kth Smallest Numbers in Unsorted Array](./java/KthSmallestNumbersinUnsortedArray.java)
* [Triangle Count](./java/TriangleCount.java)
* [Minimum Window Substring](./java/MinimumWindowSubstring.java)
* [Kth Largest Element](./java/KthLargestElement.java)

## level 2 UnionFind & Trie
* [Number of Islands](./java/NumberOfIslands.java)
* [Number of Islands II](./java/NumberOfIslands2.java)
* [Connecting Graph](./java/ConnectingGraph.java)
* [Connecting Graph II](./java/ConnectingGraph2.java)
* [Connecting Graph III](./java/ConnectingGraph3.java)
* [Graph Valid Tree](./java/GraphValidTree.java)
* [Add and Search Word](./java/AddandSearchWord.java)
* [Implement Trie](./java/ImplementTrie.java)
* [Find the Weak Connected Component in the Directed Graph](./java/FindtheWeakConnectedComponentintheDirectedGraph.java)
* [Connected Component in Undirected Graph](./java/ConnectedComponentinUndirectedGraph.java)
* [Word Search](./java/WordSearch.java)
* [Word Search II](./java/WordSearch2.java)
* [Surrounded Regions](./java/SurroundedRegions.java)
* [Boggle Game](./java/BoggleGame.java)
* [Word Squares](./java/WordSquares.java)
* [Kth Smallest Sum In Two Sorted Arrays](./java/KthSmallestSumInTwoSortedArrays.java)
* [Count of Smaller Number before itself](./java/CountofSmallerNumberBeforeItself.java)
* [Interval Sum](./java/IntervalSum.java)
* [Interval Sum II](./java/IntervalSum2.java)

## level 3 Heap & Stack
* [Expression Expand](./java/ExpressionExpand.java)
* [Trapping Rain Water](./java/TrappingRainWater.java)
* [Trapping Rain Water II](./java/TrappingRainWater2.java)
* [Implement Queue by Two Stacks](./java/ImplementQueuebyTwoStacks.java)
* [Min Stack](./java/MinStack.java)
* [Sliding Window Median](./java/SlidingWindowMedian.java)
* [Maximal Rectangle](./java/MaximalRectangle.java)
* [Max Tree](./java/MaxTree.java)
* [Largest Rectangle in Histogram](./java/LargestRectangleinHistogram.java)
* [Data Stream Median](./java/DataStreamMedian.java)
* [Sliding Window Maximum](./java/SlidingWindowMaximum.java)
* [Binary Tree Maximum Path Sum](./java/BinaryTreeMaximumPathSum.java)
* [Binary Tree Maximum Path Sum II](./java/BinaryTreeMaximumPathSum2.java)
* [Heapify](./java/Heapify.java)
* [K Edit Distance](./java/KEditDistance.java)
* [Maximal Rectangle](./java/MaximalRectangle.java)
* [Expression Tree Build](./java/ExpressionTreeBuild.java)
* [Convert Expression to Reverse Polish Notation](./java/ConvertExpressiontoReversePolishNotation.java)
* [Convert Expression to Polish Notation](./java/ConvertExpressiontoPolishNotation.java)
* [Expression Evaluation](./java/ExpressionEvaluation.java)
* [The Skyline Problem](./java/TheSkylineProblem.java)

## level 4 Binary Search + Sweep Line
* [Sqrt(x)](./java/Sqrt.java)
* [Sqrt(x) II](./java/Sqrt2.java)
* [Maximum Average Subarray II](./java/MaximumAverageSubarray2.java)
* [Number of Airplanes in the Sky](./java/NumberofAirplanesintheSky.java)
* [Divide Two Integers](./java/DivideTwoIntegers.java)
* [Find Peak Element](./java/FindPeakElement.java)
* [Find Peak Element II](./java/FindPeakElement2.java)
* [First Bad Version](./java/FirstBadVersion.java)
* [Copy Books](./java/CopyBooks.java)
* [Wood Cut](./java/WoodCut.java)
* [Find the Duplicate Number](./java/FindtheDuplicateNumber.java)
* [Smallest Rectangle Enclosing Black Pixels](./java/SmallestRectangleEnclosingBlackPixels.java)
* [Building Outline](./java/BuildingOutline.java)

## level 5 Dynamic Problem I
* [Longest Increasing Continuous Subsequence](./java/LongestIncreasingContinuousSubsequence.java)
* [Longest Increasing Continuous subsequence II](./java/LongestIncreasingContinuousSubsequence2.java)
* [Maximum Subarray](./java/MaximumSubarray.java)
* [Maximal Square](./java/MaximalSquare.java)
* [Maximal Square II](./java/MaximalSquare2.java)
* [Longest Palindromic Substring](./java/LongestPalindromicSubstring.java)
* [Coins in a Line](./java/CoinsinaLine.java)
* [Coins in a Line II](./java/CoinsinaLine2.java)
* [Coins in a Line III](./java/CoinsinaLine3.java)
* [House Robber](./java/HouseRobber.java)
* [House Robber II](./java/HouseRobber2.java)
* [House Robber III](./java/HouseRobber3.java)
* [Maximum Product Subarray](./java/MaximumProductSubarray.java)
* [Longest Increasing Subsequence](./java/LongestIncreasingSubsequence.java)
* [Copy Books](./java/CopyBooks.java)
* [Copy Books II](./java/CopyBooks2.java)
* [Longest Repeating Subsequence](./java/LongestRepeatingSubsequence.java)
* [Post Office Problem](./java/PostOfficeProblem.java)
* [Best Time to Buy and Sell Stock](./java/BestTimetoBuyandSellStock.java)
* [Best Time to Buy and Sell Stock II](./java/BestTimetoBuyandSellStock2.java)
* [Best Time to Buy and Sell Stock III](./java/BestTimetoBuyandSellStock3.java)
* [Best Time to Buy and Sell Stock IV](./java/BestTimetoBuyandSellStock4.java)
* [Best Time to Buy and Sell Stock with Cooldown](./java/BestTimetoBuyandSellStockwithCooldown.java)
* [Best Time to Buy and Sell Stock with Transaction Fee](./java/BestTimetoBuyandSellStockwithTransactionFee.java)

## level 6 Dynamic Problem II
* [Stone Game](./java/StoneGame.java)
* [Stone Game II](./java/StoneGame2.java)
* [Edit Distance](./java/EditDistance.java)
* [K Edit Distance](./java/KEditDistance.java)
* [Backpack](./java/Backpack.java)
* [Backpack II](./java/Backpack2.java)
* [Backpack III](./java/Backpack3.java)
* [Backpack IV](./java/Backpack4.java)
* [Backpack V](./java/Backpack5.java)
* [Backpack VI](./java/Backpack6.java)
* [Longest Common Subsequence](./java/LongestCommonSubsequence.java)
* [Scramble String](./java/ScrambleString.java)
* [Distinct Subsequences](./java/DistinctSubsequences.java)
* [Minimum Adjustment Cost](./java/MinimumAdjustmentCost.java)
* [Interleaving String](./java/InterleavingString.java)
* [Burst Balloons](./java/BurstBalloons.java)
* [k Sum](./java/kSum.java)
* [k Sum II](./java/kSum2.java)
* [Coins in a Line](./java/CoinsinaLine.java)
* [Coins in a Line II](./java/CoinsinaLine2.java)
* [Coins in a Line III](./java/CoinsinaLine3.java)
* [Combination Sum IV](./java/CombinationSum4.java)

## level 7 Follow Up
* [Flatten Binary Tree to Linked List](./java/FlattenBinaryTreetoLinkedList.java)
* [Flatten List](./java/FlattenList.java)
* [Subarray Sum](./java/SubarraySum.java)
* [Subarray Sum II](./java/SubarraySum2.java)
* [Flatten Nested List Iterator](./java/FlattenNestedListIterator.java)
* [Submatrix Sum](./java/SubmatrixSum.java)
* [Continuous Subarray Sum](./java/ContinuousSubarraySum.java)
* [Continuous Subarray Sum II](./java/ContinuousSubarraySum2.java)
* [Kth Smallest Number in Sorted Matrix](./java/KthSmallestNumberInSortedMatrix.java)
* [Minimum Size Subarray Sum](./java/minimumSizeSubarraySum.java)
* [Subarray Sum Closest](./java/SubarraySumClosest.java)
* [Find Peak Element](./java/findPeakElement.java)
* [Find Peak Element II](./java/FindPeakElement2.java)
* [Sliding Window Matrix Maximum](./java/SlidingWindowMatrixMaximum.java)
* [Maximum Gap](./java/MaximumGap.java)
* [Nested List Weight Sum](./java/NestedListWeightSum.java)
* [Flatten 2D Vector](./java/Flatten2DVector.java)
* [Bomb Enemy](./java/BombEnemy.java)
* [Zigzag Iterator](./java/ZigzagIterator.java)
* [Zigzag Iterator II](./java/ZigzagIterator2.java)
* [Build Post Office](./java/BuildPostOffice.java)
* [Build Post Office II](./java/BuildPostOffice2.java)

# Leet Code
* [#1. Tow Sum](./java/TwoSum.java) [&&ruby](./ruby/two_sum.rb) [&&go](./go/two_sum.go)
* [#2. Add Two Numbers](./java/addTwoNumbers.java)
* [#21. Merge Two Sorted Lists](./java/mergeTwoSortedLists.java) [&&ruby](./ruby/merge_two_sorted_lists.rb)
* [#26. Remove Duplicates from Sorted Array](./java/RemoveDuplicatesfromSortedArray.java)
* [#77. Combinations](./java/combinations.java)
* [#111. Minimum Depth of Binary Tree](./java/minimumDepthOfBinaryTree.java)
* [#107. Binary Tree Level Order Traversal II](./java/binaryTreeLevelOrderTraversal2.java)
* [#141. Linked List Cycle](./java/linkedListCycle.java)
* [#142. Linked List Cycle II](./java/linkedListCycle2.java)
* [#209. Minimum Size Subarray Sum](./java/minimumSizeSubarraySum.java)
* [#287. Find the Duplicate Number](./java/findTheDuplicateNumber.java)
* [#345. Reverse Vowels of a String](./ruby/reverseVowelsOfAString.rb)
* [#409. Longest Palindrome](./ruby/longest_palindrome.rb)

# Algorithm
## Binary Search
* OlogN
* start + (end - start) / 2

* [Swap Bits](./java/)
* [A + B Problem](./java/)
* [Update Bit](./java/)
* [Count 1 in Binary](./java/)
* [Flip Bits](./java/)
* [O(1) Check Power of 2](./java/)
* [Single Number](./java/)
* [Single Number II](./java/)
* [Single Number III](./java/)

## Robin-Karp

## Topological sorting

## External Sorting

## Binary Index Tree

## Divide Coquer

## Breadth First Search

## Depth First Search
* [pre order]()
* [in order]()
* [post order]()
* 优化
  * 重复计算 无效计算

## Backtracking
* 深搜中出栈的那一步

## Two Pointers
* window 同向双指针
* 数据流

## Dynamic Programming
* 记忆化搜索
* 子问题有交集
* 状态定义 => 初始化 => 循环递推求解 => 求结果:起点
* 题型: 最值，判断可行性，统计方案个数
* 2^n n! => n^2 n^3

## Moving window

```java
for (int i = 0; i < n; i++) {
    while(j < n) {
        if(满足条件) {
            j++;
            更新j状态
        } else(不满足条件) {
            break;
        }
        更新i状态
    }
}
```

## Scan-line algorithm

## Quick Sort


# Data Structure
## Stack
* LIFO

```java
public class Stack {
    private int[] data;
    private int size;
    private int top = 0; // 指向栈的顶部

    public Stack(int size) {
        this.size = size;
        this.data = new int[size];
    }
}
```

## Queue
* FIFO



## Linked List
* [Middle of the Linked List](./go/middle_of_the_linked_list.go)
* [Reverse Linked List](./go)
* [Merge Two Sorted Lists](./go)
* [Linked List Cycle](./go)
* [Delete Node in a Linked List](./go)
* 注意点
  * 如果链表为空时，代码是否能正常工作？
  * 如果链表只包含一个结点时，代码是否能正常工作？
  * 如果链表只包含两个结点时，代码是否能正常工作？
  * 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

```java
class LinkNode {
    public int data;
    public LinkNode next;

    public LinkNode(int data) {
        this.data = data;
        this.next = null;
    }
}
```

## Array

## Hash Table
* O(size of key)
* 用来查重
* 替代: BBST => TreeSet，trie，BloomFilter

* LFU
* LRU

## Binary Tree

```java
class Node {
    public Object data;
    public Node left;
    public Node right;
}
```

## Heap
* vs PriorityQueue


|               | TreeMap    |  Heap    |   PriorityQueue |
| :----------   | :-------:  | :------: | :-------------: |
| 1. Insert()   |    logn    |   logn   |      logn       |
| 2. Delete()   |    logn    |   logn   |      O(n) / X   |
| 3. Pop()      |    logn    |   logn   |      logn       |
| 4. Find()     |    logn    |   logn   |        X        |
| 5. Modify()   |    logn    |   logn   |        X        |
| 6. Min / Max  |    logn    |   O(1)   |      O(1)       |
| 7. upper / lower | logn    |     X    |        X        |


## Union Find

```
class UnionFind{
    HashMap<Integer, Integer> father = new HashMap<Integer, Integer>();
    UnionFind(int n){
        for(int i = 0 ; i < n; i++) {
            father.put(i, i);
        }
    }
    int compressed_find(int x){
        int parent =  father.get(x);
        while(parent!=father.get(parent)) {
            parent = father.get(parent);
        }
        int temp = -1;
        int fa = father.get(x);
        while(fa!=father.get(fa)) {
            temp = father.get(fa);
            father.put(fa, parent) ;
            fa = temp;
        }
        return parent;
    }

    void union(int x, int y){
        int fa_x = compressed_find(x);
        int fa_y = compressed_find(y);
        if(fa_x != fa_y)
            father.put(fa_x, fa_y);
    }
}
```

```java
public class UnionFind {
    private int[] father = null;

    public int find(int x) {
        if (father[x] == x) {
            return x;
        }
        return father[x] = find(father[x]);
    }

    public void union(int a, int b) {
        int root_a = find(a);
        int root_b = find(b);
        if (root_a != root_b) {
            father[root_a] = root_b;
        }
    }
}
```

## Trie
[ex](./ruby/trie_tree.rb)

```java
class TrieNode {
    public TrieNode[] children;
    public boolean isWord;

    public TrieNode() {
        children = new TrieNode[26];
        for (int i = 0; i < 26; ++i) {
            children[i] = null;
        }
        isWord = false;
    }
}

private TrieNode root;

public WordDictionary(){
    root = new TrieNode();
}

public void addWord(String word) {
    // write your code here
    TrieNode current = root;
    for(int i = 0; i < word.length(); i++) {
        Character c = word.charAt(i);
        if (current.children[c - 'a'] == null) {
            current.children[c - 'a'] = new TrieNode();
        }
        current = current.children[c - 'a'];
    }
    current.isWord = true;
}

boolean find(String word, int index, TrieNode now) {
    if(index == word.length()) {
        return now.isWord;
    }

    Character c = word.charAt(index);
    if (c == '.') {
        for(int i = 0; i < 26; ++i)
        if (now.children[i] != null) {
            if (find(word, index+1, now.children[i]))
                return true;
        }
        return false;
    } else if (now.children[c - 'a'] != null) {
        return find(word, index+1, now.children[c - 'a']);
    } else {
        return false;
    }
}
```

* 和Hash比更加节约空间
* 可用来优化某些dfs

## Graph


## DP
* state, function, intialization, result
* 记忆化搜索来达到减枝的目的
* 矩阵
* 记忆化搜索
 * 状态转移特别麻烦，不是顺序性
 * 初始化状态不好找
 * 从大到小
* 博弈类
 * 画出搜索树，只考虑先手策略
* 空间类

# other
* crack and code inetrview